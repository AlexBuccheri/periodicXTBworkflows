from scipy.optimize import curve_fit
import numpy as np
import math


def birch_murnaghan_relation(volume: np.array,
                             ground_state_energy: float,
                             eq_volume: float,
                             bulk_modulus: float,
                             pressure_derivative: float) -> np.array:
    """ A function object of birch murnaghan relation:

    E(V) = E_0 + \frac{9V_0B_0}{16} \left\{\left[\left(\frac{V_0}{V} \right)^{2/3}  - 1\right]^3 B_1 +
            \left[\left(\frac{V_0}{V} \right)^{2/3}  - 1\right]^2 \left[6 - 4\left(\frac{V_0}{V} \right)^{2/3}\right]\right\}

    which is described in the paper
    https://doi.org/10.1080/10408436.2013.772503
    :param volume: an array of volume as the input of the curve.
    :param ground_state_energy: E_0 in the birch murnaghan relation.
    :param eq_volume: equilibrium volume, V_0.
    :param bulk_modulus: B_0.
    :param pressure_derivative: B_1.
    :return: an array of energy generated by the relation
    """

    rel_volume_ratio = np.power(eq_volume / volume, 2 / 3)
    intermediate_term_1 = rel_volume_ratio - 1.0
    intermediate_term_2 = 6.0 - 4.0 * rel_volume_ratio
    term_in_large_bracket = np.power(intermediate_term_1, 3.0) * pressure_derivative + \
                            np.power(intermediate_term_1, 2.0) * intermediate_term_2

    return ground_state_energy + 9.0 / 16.0 * eq_volume * bulk_modulus * term_in_large_bracket


# TODO Rui Have this return the evaluated birch_murnaghan_relation? I.e return np.array not Callable
def parse_birch_murnaghan_relation(bm_params: dict):
    def wrapped_birch_murnaghan_relation(volume: np.array) -> np.array:
        return birch_murnaghan_relation(volume,
                                        bm_params['ground_state_energy']['value'],
                                        bm_params['eq_volume']['value'],
                                        bm_params['bulk_modulus']['value'],
                                        bm_params['pressure_derivative']['value'])

    return wrapped_birch_murnaghan_relation


def fit_birch_murnaghan_relation(volume: np.array, energy: np.array,
                                 estimated_bulk_modulus=10.0,
                                 estimated_pressure_derivative=3.0,
                                 **curve_fit_kwargs) -> dict:
    """ Use scipy's curve-fitting routine to fit birch_murnaghan_relation for an existing energy vs volume curve.

    Rhe default guess provided is an overall estimate from the numbers in the paper
    https://doi.org/10.1080/10408436.2013.772503.

    :param volume: an array of volume as the input of the curve.
    :param energy: the corresponding energy
    :param estimated_bulk_modulus: an initial guess for the bulk modulus B_0
    :param estimated_pressure_derivative: an initial guess for the pressure_derivative B_1.
    :param curve_fit_kwargs: The fitting parameters that go into the scipy's curve_fit routine.
    :return: a dictionary that contains all the parameters of birch-murnaghan relation.
    """
    min_energy_index = np.argmin(energy)
    estimated_eq_volume = volume[min_energy_index]
    estimated_ground_state_energy = energy[min_energy_index]

    initial_guess = np.array([
        estimated_ground_state_energy,
        estimated_eq_volume,
        estimated_bulk_modulus,
        estimated_pressure_derivative
    ])

    optimized_values, covariance = curve_fit(birch_murnaghan_relation, volume, energy, p0=initial_guess, **curve_fit_kwargs)
    error_values = np.sqrt(np.diag(covariance))

    optimized_results = {
        "ground_state_energy": {"value": optimized_values[0], "error": error_values[0]},
        "eq_volume":           {"value": optimized_values[1], "error": error_values[1]},
        "bulk_modulus":        {"value": optimized_values[2], "error": error_values[2]},
        "pressure_derivative": {"value": optimized_values[3], "error": error_values[3]}
    }

    return optimized_results


class EVCurveData:
    def __init__(self, volume: np.array, energy: np.array):
        volume, energy = np.asarray(volume), np.asarray(energy)
        assert (volume.shape == energy.shape)

        self.volume = volume
        self.energy = energy
        self.fitted_parameters = None


def calculate_birch_murnaghan_relation(data: EVCurveData,
                                       estimated_bulk_modulus=10.0,
                                       estimated_pressure_derivative=3.0,
                                       **curve_fit_kwargs) -> EVCurveData:
    """
    """
    data.fitted_parameters = fit_birch_murnaghan_relation(data.volume, data.energy,
                                                          estimated_bulk_modulus=estimated_bulk_modulus,
                                                          estimated_pressure_derivative=estimated_pressure_derivative,
                                                          **curve_fit_kwargs)

    return data


def delta_factor(ev_curve_data_1: EVCurveData, ev_curve_data_2: EVCurveData, equilibrium_volume: float,
                 n_points: int = 100) -> float:
    """Calculate the delta factor of two E vs V curves, which is defined as:

    \Delta = \sqrt{\frac{\int_{0.94}^{1.06} (E_1(V) - E_2(V))^2 dV }{0.12 V_0}}

    Note that to this is w.r.t. the unit cell. One should consider dividing the final
    result by the number of atoms in the cell.

    Defined according to eq (1) in paper DOI: 10.1126/science.aad3000
    """
    assert ev_curve_data_1.fitted_parameters
    assert ev_curve_data_2.fitted_parameters

    ev_curve_1 = parse_birch_murnaghan_relation(ev_curve_data_1.fitted_parameters)
    ev_curve_2 = parse_birch_murnaghan_relation(ev_curve_data_2.fitted_parameters)

    vol = np.linspace(0.94, 1.06, n_points) * equilibrium_volume
    # Volume element
    dv = vol[1] - vol[0]

    energy_array_from_1 = ev_curve_1(vol) - ev_curve_data_1.fitted_parameters["ground_state_energy"]["value"]
    energy_array_from_2 = ev_curve_2(vol) - ev_curve_data_2.fitted_parameters["ground_state_energy"]["value"]

    variance = energy_array_from_1 ** 2 + energy_array_from_2 ** 2 - 2.0 * energy_array_from_1 * energy_array_from_2

    # Half the values of the first & last element to perform trapezoid numerical integral
    variance[0] = variance[0] / 2.0
    variance[-1] = variance[-1] / 2.0
    integral = np.sum(variance) * dv

    return math.sqrt(integral / (0.12 * equilibrium_volume))
